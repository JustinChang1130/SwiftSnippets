# Swift Programming Guide

>程式碼需要大家共同維護保持整潔，我很喜歡 clean code 一書中提到的，童子軍規則（The Boy Scout Rule）：離開營地前，讓營地比使用前更加乾淨。
>讓你每次異動的檔案都比之前乾淨一點，哪怕只是調整一個合理空格縮排，刪除一行註解程式碼，或是重新命名一個更加貼切的名稱，讓程式碼的品質好上那麼一點點，慢慢的它就會越來越乾淨。讓你我開發都可以越來越舒服

以下規範 swift 撰寫規範，會基於 [Apple API Design Guidelines](https://www.swift.org/documentation/api-design-guidelines/) 規範，再加入部分 [Google Swift Style Guide](https://google.github.io/swift/#apples-api-style-guidelines/) 規範



## 目錄

* [基本原則](#基本原則)
* [命名](#命名)
  * [名副其實](#名副其實)
  * [流暢的使用](#流暢的使用)
  * [合理的使用術語](#合理的使用術語)
* [常規](#常規)
  * [基本常規](#基本常規)
  * [Parameter](#Parameter)
  * [Argument Labels](#ArgumentLabels)
* [特殊說明](#特殊說明)

## 基本原則
* **清晰的傳達使用意圖**是最主要的目標，在設計 API 時，應盡可能保證這個實體的使用簡單明了，職責單一。再評估某個設計好壞時，需要將其放在其使用場景下，檢查其含義是否做到清晰明了。

* **傳達清晰的意圖比文字簡潔更重要**，Swift 程式可以寫的十分簡潔，但用最少的字來撰寫程式並非 Swift 的設計本意。Swift 程式之所以看起來非常簡潔，只是 strongly typed 系統和各種特性帶來的效果，無形中減少了模板代碼（boilerplate）的使用。

* **編寫文檔註釋的工作**落實到每一個宣告中。編寫文檔註釋可以加深對程式理解，從而對你的設計產生深遠的影響，所以不要偷懶。
    > 如果無法用簡單的文字來描述你設計的 API ，那麼**你很有可能在設計 API 上出了問題。 (做的事情太多，違反單一職責)**
    >
    > (這裡不硬性規定一定要為每一個宣告加入註釋，可以很清楚傳達意圖時不一定要加註文檔說明)

    * **善用 Swift 提供 [特别版 Markdown 語法](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/)**
    
    * **閱讀 API 的宣告和摘要就可以完全理解其用途：**

		```swift
		/// Returns a "view" of `self` containing the same elements in
		/// reverse order.
		func reversed() -> ReverseCollection
		```
      
	* **用一個語句片段進行描述，並用句號結尾。不要寫一個複雜的句子**
	* **描述一個方法做什麼，以及會返回什麼**
	* **描述 subscript access 的内容：**

		```swift
		/// Accesses the `index`th element.
		subscript(index: Int) -> Element { get set }
		```

	* **描述 init 的内容：**

		```swift
		/// Creates an instance containing `n` repetitions of `x`.
		init(count n: Int, repeatedElement x: Element)
		```

	* 對於其他 API 的宣告，**需要描述清楚宣告的實體到底是什麼：**

		```swift
		/// A collection that supports equally efficient insertion/removal
		/// at any position.
		struct List {
		      
		/// The element at the beginning of `self`, or `nil` if self is
		/// empty.
		var first: Element?
		...
		```

	* **如果需要，可以繼續添加一個或多個段落並有序排列這些條目**，但是段落應該使用空行隔開，並使用完整的句子進行描述。

	    ```swift
	    /// Writes the textual representation of each    ← Summary
	    /// element of `items` to the standard output.
	    ///                                              ← Blank line
	    /// The textual representation for each item `x` ← Additional discussion
	    /// is generated by the expression `String(x)`.
	    ///
	    /// - Parameter separator: text to be printed    ⎫
	    ///   between items.                             ⎟
	    /// - Parameter terminator: text to be printed   ⎬ Parameters section
	    ///   at the end.                                ⎟
	    ///                                              ⎭
	    /// - Note: To print without a trailing          ⎫
	    ///   newline, pass `terminator: ""`             ⎟
	    ///                                              ⎬ Symbol commands
	    /// - SeeAlso: `CustomDebugStringConvertible`,   ⎟
	    ///   `CustomStringConvertible`, `debugPrint`.   ⎭
	    public func print(
	      _ items: Any..., separator: String = " ", terminator: String = "\n")
	    ```
	* **使用可識別的符號文檔標記元素**，為註釋添加摘要以外的任意信息。
	* **了解並使用符號命令語法做條目**。像 Xcode 等主流開發工具為這些條目提供了特殊的處理，其關鍵詞如下：

        |||||
        |:--- | :--- | :--- | :--- |
        |[Attention](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html) | [Author](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Author.html) | [Authors](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Authors.html) | [Bug](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Bug.html)
        |[Complexity](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Complexity.html) | [Copyright](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Copyright.html) | [Date](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Date.html) | [Experiment](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Experiment.html) |
        |[Important](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Important.html)|[Invariant](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Invariant.html)|[Note](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Note.html)|[Parameter](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameter.html)|
        |[Parameters](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameters.html)|[Postcondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Postcondition.html)|[Precondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Precondition.html)|[Remark](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Remark.html)|
        |[Requires](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Requires.html)|[Returns](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Returns.html)|[SeeAlso](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SeeAlso.html)|[Since](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Since.html)|
        |[Throws](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Throws.html)|[ToDo](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Todo.html)|[Version](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Version.html)|[Warning](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Warning.html)|


## 命名

### 名副其實

* **盡可能描述避免困惑**

  例如：下面這個方法可以移除集合中指定位置的元素。

    ```swift
    👍👍👍
    extension List {
      public mutating func remove(at position: Index) -> Element
    }
    employees.remove(at: x)
    ```
  
  如果我們省略方法外部命名的 `at`，它可能暗示讀者該方法會搜索並刪除集合中等於 `x` 的 element，而不是刪除位置是 `x` 的 element。

    ```swift
    👎👎👎
    employees.remove(x) // unclear: are we removing x?
    ```
    
* **產生有意義的區別**

  如果你在一個類別中同時看到下面三個方法你會知道你應該呼叫哪一個？
    
    ```swift
    👎👎👎
    getActiveAccount()
    getActiveAccounts()
    getActiveAccountInfo()
    ```
    在沒有特殊約定的情況下，變數名稱 moneyAmount 和 money 是沒有區別，customerInfo 和 customer 也是一樣，accountData 也和和 account 沒有區別，還有 theMessage 及 message，所以要上讀者可以辨識區別的名稱來命名 
  

* **刪除無意義的字**，每個字詞都需要傳達出相應的關鍵訊息。

  更多的字詞或許可以明確意圖，但是那些多餘訊息是可以省略的。尤其是那些重複類型詞語。

    ```swift
    👎👎👎
    public mutating func removeElement(_ member: Element) -> Element?
    allViews.removeElement(cancelButton)
    ```

  在上面的程式中，`Element` 在調用時沒有提供任何有效的信息，API 修改成下面這樣會更好。

    ```swift
    👍👍👍
    public mutating func remove(_ member: Element) -> Element?
    allViews.remove(cancelButton) // clearer
    ```
    
  或是
    
    ```swift
    👍👍👍
    var name: String
    
    👎👎👎
    var nameString: String // name 直覺上就是 string 他不太可能是其他東西
    ```
  或是  
        
    ```swift
    👍👍👍
    struct Order {
        var name: String
    }
    let order = Order()
    print(order.name)
    
    👎👎👎
    struct Order {
        var orderName: String
    }
    
    let order = Order()
    print(order.orderName) // name 隸屬於 Order 之中所以命名成 'order'Name 在使用環境上就是多餘贅詞
    
    ```



  在個別情況下，重複類型信息對於消除歧義是有幫助的。但總的來說，最好能描述作用，而不是類型。詳見下一規則。

* **根據作用來命名**，而不是基於它們的類型。

  ```swift
  👎👎👎
  var string = "Hello"
  protocol ViewController {
    associatedtype ViewType : View
  }
  
  class ProductionLine {
    func restock(from widgetFactory: WidgetFactory)
  }
  ```

  這裡需要再提醒一遍，單純的重複類型名稱對傳遞清晰的意圖和提升表達性來說，幫助並不大。相反，你應該盡量選用那些表明實體作用的名字。
  
  ```swift
  👍👍👍
  var greeting = "Hello"
  protocol ViewController {
    associatedtype ContentView : View
  }
  
  class ProductionLine {
    func restock(from supplier: WidgetFactory)
  }
  ```

  如果 associated type 和遵循的協議命名衝突，可以在協議名後面加上 `protocol`：

  ```swift
  protocol Sequence {
    associatedtype Iterator : IteratorProtocol
  }
  
  protocol IteratorProtocol { ... }
  ```


* **為 weak type 參數補充訊息**以明確參數的作用。

  當參數類型是 `NSObject`、`Any`、`AnyObject` 或者是基礎類型比如 `Int`、`String` 時，調用處的類型訊息在環境中可能無法完全表明函數意圖。在下面的例子中，它的宣告看起來語義明確，但從調用者的角度來看，就顯得不夠清晰。

  ```swift
  👎👎👎
  func add(_ observer: NSObject, for keyPath: String)
  grid.add(self, for: graphics) // vague
  ```

  為了清晰的傳達 API 本身的意圖，**可以在每個參數前加一個名詞來描述它的作用。**

  ```swift
  👍👍👍
  func addObserver(_ observer: NSObject, forKeyPath path: String)
  grid.addObserver(self, forKeyPath: graphics) // clear
  ```

### 流暢的使用

* **方法名最好能在調用處形成符合語法規範的英語短語。**

  ```swift
  👍👍👍
  x.insert(y, at: z)          “x, insert y at z”
  x.subViews(havingColor: y)  “x's subviews having color y”
  x.capitalizingNouns()       “x, capitalizing nouns”
  ```

  ```swift
  👎👎👎
  x.insert(y, position: z)
  x.subViews(color: y)
  x.nounCapitalize()
  ```

  為了使用起來更流暢，可以從第二個或者第三個參數開始降低命名要求，前提是這些參數不影響整個 API 的語義。

  ```swift
  AudioUnit.instantiate(with: description, 
                        options: [.inProcess], 
                        completionHandler: stopProgressBar)
  ```

* **工廠方法的命名要以 make 開頭**，如：`x.makeIterator()`。

* **init 方法和 [工廠方法](https://en.wikipedia.org/wiki/Factory_method_pattern)** 的第一個參數命名不應該考慮方法名，應該獨立命名，如：`x.makeWidget(cogCount: 47)`

  下面這些方法調用中，第一個參數並沒有和方法名組成連續的短語：

  ```swift
  👍👍👍
  let foreground = Color(red: 32, green: 64, blue: 128)
  let newPart = factory.makeWidget(gears: 42, spindles: 14)
  let ref = Link(target: destination)
  ```
  
  下面的例子中，API 作者試圖將第一個參數名和方法名拼成連續的短語。

  ```swift
  👎👎👎
  let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)
  let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)
  let ref = Link(to: destination)
  ```

  在實際使用中，本規則和 [Argument Labels](#Argument Labels) 的相關規則組合起來，意味著第一個參數一般都會有標籤，除非執行的是 [值保留類型轉換](#type-conversion) 操作。

  ```swift
  let rgbForeground = RGBColor(cmykForeground)
  ```

* **根據函數和方法的 side effects 進行命名**

  * 沒有 side effects 的方法讀起來應該像名詞短語，例如，`x.distance(to: y)`。

  * 有 side effects 的方法讀起來應該像祈使動詞，例如，`x.sort()`，`x.append(y)`。

  * **Mutating / Nonmutating 方法的命名要成對出現**。一個 Mutating 方法通常都有一個 Nonmutating 方法與之對應，二者的語義相近，區別在於前者更新實體，而後者返回一個新值。

  * 當一項操作**恰好能夠被一個動詞描述時**，使用動詞原形為 Mutating 方法命名；使用動詞的過去分詞 (ed) 或現在分詞 (ing) 為 Nonmutating 方法命名。
  
     |Mutating|Nonmutating|
     |:-:|:-:|
     |x.sort()|z = x.sorted()|
     |x.append(y)|z = x.appending(y)|
          

  * 命名不可變方法，最好使用過去分詞（通常是增加後綴 “ed”）：


    ```swift
    /// Reverses `self` in-place.
    mutating func reverse()
    
    /// Returns a reversed copy of `self`.
    func reversed() -> Self
    ...
    x.reverse()
    let y = x.reversed()
    ```
        

  * 如果由於動詞後面直接跟隨一個對象，無法添加 “ed” 時，使用現在分詞命名不可變方法，即後綴 “ing”。
        
    ```swift
    /// Strips all the newlines from `self`
    mutating func stripNewlines()
    
    /// Returns a copy of `self` with all the newlines stripped.
    func strippingNewlines() -> String
    ...
    s.stripNewlines()
    let oneLine = t.strippingNewlines()
    ```
        

  * 當一項操作**恰好能夠被一個名詞描述時**，使用名詞本身為 Nonmutating 方法命名；使用名詞前加 “form” 的方式為 Mutating 方法命名。

      |Nonmutating|Mutating|
      |:-:|:-:|
      |x = y.union(z)|y.formUnion(z)|
      |j = c.successor(i)|c.formSuccessor(&i)|


* **對於返回值是 bool 的方法和屬性，讀起來應該像是對被調用物件的 assertion**，其使用場景是不可變方法。例如，`x.isEmpty`，`line1.intersects(line2)`。

* **描述事物的 Protocol，應為名词**（例如，`Collection`）。

* **描述能力的 Protocol，應使用後缀 `able`，`ible` 或 `ing`**（例如，Equatable，ProgressReporting）。

* 其他**類型，屬性，變數以及常數，應為名詞**。

### 其他命名規範
* array 型別變數名稱加上 s

    ```swift
    var categories = [String]()
    ```
    
* UI 元件命名請為其結尾加上元件類型

    ```swift
    @IBOutlet weak var titleLabel: UILabel!
    @IBOutlet weak var confirmButton: UIButton!
    ```
    
* UI 元件事件觸發的 function 名為 `元件名稱` + `事件描述`
    ```swift
    @IBAction func confirmButtonPressed(_ sender: UIButton) {
        //...
    }
    ```



### 合理的使用術語
> 在某個領域或行業內，有著明確特殊含義的詞或短語。

* **避免使用晦澀的術語**，特別是在有一個常見詞彙能夠表達同樣含義時。例如，如果 ”skin“ 能夠滿足表述需求，就不要使用 ”epidermis“。術語是重要的交流工具，但應該僅在其他表述方式會丟失關鍵意義時，才使用這些比較生僻的術語。

  * **別嚇著專家**：如果對某個術語十分熟悉的人發現 API 設計者為該術語發明了新的含義。他們可能會感到驚訝甚至憤怒。

  * **別迷惑新手**：嘗試學習術語的人一般都會通過網路搜索的方式查詢術語的原始含義。

* 避免縮寫，特別是非標準縮寫，本質上是一個術語。

* **遵循先例**。如果現有術語已經能夠完美表述一個含義，那麼就不要為了遷就新手，打破這種先例。

  例如，最好將一個連續的資料結構命名為 `Array`，而非更簡單的 `List`，雖然對於新手來說，後者的含義更容易掌握。 Array 是現代計算機科學的基礎資料結構，所以每個工程師都知道——或者很快就能理解——什麼是 Array。使用大多數工程師所熟悉的術語，這樣，即便有問題，其他人也能夠提供幫助。
  
  在某些特定的編程領域，例如數學， 諸如 `sin(x)` 這樣已經廣為人們所接受的術語，要比諸如 `verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle(x)` 這樣解釋性的命名好的多。注意，這裡先例打破了避免縮寫的規則：儘管單詞的完整拼寫是 `sine`，但 ”`sin(x)`“ 已經被程序員使用了數十年，在數學中更是數百年。

## 常規

### 基本常規

* **對於複雜度不是 O(1) 的計算型屬性，要通過註釋特別說明** 。人們總是認為屬性訪問不牽扯大量計算，因為在人類的心智模型裡會潛意識的認為當前訪問的只是一個存儲型屬性。當這個假設被打破時，有必要提醒他們。

* **優先選擇方法或屬性，而非 free function。free function 只在下述情況中使用：**

  * 沒有對象:

      ```swift
      min(x, y, z)
      ```

  * 是不受限的泛型函数：

      ```swift
      print(x)
      ```

  * 在特定的領域中已經有約定俗成函數語法在：

      ```swift
      sin(x)
      ```

* **遵守大小寫的慣例** type 和 protocol 名稱使用`大寫字母開頭的駝峰命名法`。其他名稱使用以`小寫字母開頭的駝峰命名法`。
  
  對於那些在美式英語中，全部以大寫字母出現的縮寫 [Acronym](https://en.wikipedia.org/wiki/Acronym)，應根據大小寫慣例統一大寫或小寫：

  ```swift
  var utf8Bytes: [UTF8.CodeUnit]
  var isRepresentableAsASCII = true
  var userSMTPServer: SecureSMTPServer
  var contractPDF: PDFDocument
  ```

  其他縮寫作為普通單詞對待：
  > 這裡指的 `其他縮寫` 指的是隨著時間的演化成為獨立的單詞並融入在語言和社會中的詞語

  ```swift
  var radarDetector: RadarScanner // 雷達 radar 其實是 RAdio Detection And Ranging 縮寫
  var enjoysScubaDiving = true // 水肺 Scuba 其實是 Self-Contained Underwater Breathing Apparatus 縮寫
  ```


* 當某些方法的含義基本一致，或者只是在不同範圍內使用的同類型方法，那麼它們可以**共享一個基礎方法名**
  
  例如，下面的命名方式值得認可，因為這些方法本質上是在做同一件事：

  ```swift
  👍👍👍
  extension Shape {
    /// Returns `true` if `other` is within the area of `self`;
    /// otherwise, `false`.
    func contains(_ other: Point) -> Bool { ... }
  
    /// Returns `true` if `other` is entirely within the area of `self`;
    /// otherwise, `false`.
    func contains(_ other: Shape) -> Bool { ... }
  
    /// Returns `true` if `other` is within the area of `self`;
    /// otherwise, `false`.
    func contains(_ other: LineSegment) -> Bool { ... }
  }
  ```
  
  由於 Shape 和 Collection 所處的 scope 不同，下面的命名方式也可以：

  ```swift
  👍👍👍
  extension Collection where Element : Equatable {
    /// Returns `true` if `self` contains an element equal to
    /// `sought`; otherwise, `false`.
    func contains(_ sought: Element) -> Bool { ... }
  }
  ```
  
  然而，下面的 `index` 方法含義各不相同，應區別命名：

  ```swift
  👎👎👎
  extension Database {
    /// Rebuilds the database's search index
    func index() { ... }
  
    /// Returns the `n`th row in the given table.
    func index(_ n: Int, inTable: TableID) -> TableRow { ... }
  }
  ```
  
  最後，避免“overloading on return type”，不可這樣寫。

  ```swift
  👎👎👎
  extension Box {
    /// Returns the `Int` stored in `self`, if any, and
    /// `nil` otherwise.
    func value() -> Int? { ... }

    /// Returns the `String` stored in `self`, if any, and
    /// `nil` otherwise.
    func value() -> String? { ... }
  }
  ```
  
<a name="Parameter"></a>

### Parameter

```swift
func move(from start: Point, to end: Point)
```

* **選擇具有說明作用的命名**。雖然 Parameter 名在函數或方法調用時並不出現，但它們扮演著重要的解釋作用。

  選擇能夠提昇文檔可讀性的名稱。下面的例子中，Parameter 名使得文檔讀起來自然流暢：

    ```swift
    👍👍👍
    /// Return an `Array` containing the elements of `self`
    /// that satisfy `predicate`.
    func filter(_ predicate: (Element) -> Bool) -> [Generator.Element]
  
    /// Replace the given `subRange` of elements with `newElements`.
    mutating func replaceRange(_ subRange: Range, with newElements: [E])
    ```
  
  而下面的讀起來很別奇怪，不符合文法：

    ```swift
    👎👎👎
    /// Return an `Array` containing the elements of `self`
    /// that satisfy `includedInResult`.
    func filter(_ includedInResult: (Element) -> Bool) -> [Generator.Element]


    /// Replace the range of elements indicated by `r` with
    /// the contents of `with`.
    mutating func replaceRange(_ r: Range, with: [E])
    ```

* 善用參數 default 值簡化使用程式

  通過隱藏無關訊息並提供參數 default 值的方式，可以提升 API 可讀性。例如：

  ```swift
  👎👎👎
  let order = lastName.compare(royalFamilyName, options: [], range: nil, locale: nil)
  ```

  加入 default 值後

  ```swift
  👍👍👍
  let order = lastName.compare(royalFamilyName)
  ```
  
  參數 default 值通常適用於一組類似的方法，這樣可以降低理解 API 的認知負擔。
  
  ```swift
  👍👍👍
  extension String {
    /// ...description...
    public func compare(_ other: String, 
                        options: CompareOptions = [],
                        range: Range? = nil, locale: Locale? = nil) -> Ordering
  }
  ```
  
  上述方法可能看起來設計的也不太好，但比下面這些強多了：

  ```swift
  👎👎👎
  extension String {
    /// ...description 1...
    public func compare(_ other: String) -> Ordering
    /// ...description 2...
    public func compare(_ other: String, options: CompareOptions) -> Ordering
    /// ...description 3...
    public func compare(_ other: String, options: CompareOptions, range: Range) -> Ordering
    /// ...description 4...
    public func compare(_ other: String, options: StringCompareOptions,range: Range, locale: Locale) -> Ordering
  }
  ```

* **將具有 default 值的參數放到方法最後**。從語義上來說，沒有 default 值參數的參數對於方法來說是更為重要。


<a name="ArgumentLabels"></a>


### Argument Labels


```swift
func move(from start: Point, to end: Point)
x.move(from: x, to: y)
```

* **如果 Argument Labels 的說明意圖的功能不大，可以省略 Argument Labels**。例如：`min(number1, number2)`。

<a name="type-conversion"></a>

* **如果 init 方法進行的是類型轉換 (preserving type conversions)，則省略第一個 Argument Labels**。例如：`Int64(someUint32)`。
  
  >第一個參數請擺放要轉換的內容

  ```swift
  extension String {
    // Convert `x` into its textual representation in the given radix
    init(_ x: BigInt, radix: Int = 10)   ← Note the initial underscore
  }

  text = "The value is: "
  text += String(veryLargeNumber)
  text += " and in hexadecimal, it's"
  text += String(veryLargeNumber, radix: 16)
  ```

  而對於縮小轉換(narrowing type conversions) 來說，最好使用第一個 Argument Label 描述所省略的內容。

  ```swift
  extension UInt32 {
    /// Creates an instance having the specified `value`.
    init(_ value: Int16)            ← Widening, so no label
    /// Creates an instance having the lowest 32 bits of `source`.
    init(truncating source: UInt64)
    /// Creates an instance having the nearest representable
    /// approximation of `valueToApproximate`.
    init(saturating valueToApproximate: UInt64)
  }
  ```

* **當第一個參數構成“介詞短語”的一部分時，請加上 Argument Label 說明**。例如，`x.removeBoxed(havingLength: 12)`。

  如果前兩個或多個參數共同組成一個抽象概念，就不需要遵守上面的約定。

  ```swift
  👎👎👎
  a.move(toX: b, y: c)
  a.fade(fromRed: b, green: c, blue: d)
  ```

  這種情況下，將介詞從 Argument Label 中抽取至方法名稱，會使該方法的語義更清晰。

  ```swift
  👍👍👍
  a.moveTo(x: b, y: c)
  a.fadeFrom(red: b, green: c, blue: d)
  ```

* **如果方法名稱已經組成一個完整意圖短語，則省略Argument Label** 例如 `x.addSubView(y)`。

  該準則意味著如果第一個參數不構成語法短語的一部分，它應該有一個 Argument Label。

  ```swift
  👍👍👍
  view.dismiss(animated: false)
  let text = words.split(maxSplits: 12)
  let studentsByName = students.sorted(isOrderedBefore: Student.namePrecedes)
  ```  
  注意，短語傳達的含義要正確。下述短語的語法正確，但會產生歧義。

  ```swift
  👎👎👎
  view.dismiss(false)   Don't dismiss? Dismiss a Bool?
  words.split(12)       Split the number 12?
  ```

  另外，有 default 值的參數因為可以省略，所以這些參數不應該參與短語的組成。
  
* **其他參數都需要加上標籤**

## 特殊說明

* **方法參數盡量少 2個以上請檢視其必要性**

* **Delegate 實作使用 extension 分別區分**

    ```swift
    👎👎👎
    class MyViewController: UIViewController, UITableViewDataSource, UIScrollViewDelegate {
        // all methods
    }
    
    👍👍👍
    class MyViewController: UIViewController {
        // class stuff here
    }

    // MARK: - UITableViewDataSource
    extension MyViewController: UITableViewDataSource {
        // table view data source methods
    }

    // MARK: - UIScrollViewDelegate
    extension MyViewController: UIScrollViewDelegate {
        // scroll view delegate methods
    }

    ```

* **如果 API 使用使用了 closure 和 tuple，請為其添加標籤**。

  這些參數的標籤不僅具有解釋作用，還可以用來直接訪問元組成員。相關的說明可以放在文檔註釋中。

  ```swift
  /// Ensure that we hold uniquely-referenced storage for at least
  /// `requestedCapacity` elements.
  ///
  /// If more storage is needed, `allocate` is called with
  /// `byteCount` equal to the number of maximally-aligned
  /// bytes to allocate.
  ///
  /// - Returns:
  ///   - reallocated: `true` if a new block of memory
  ///     was allocated; otherwise, `false`.
  ///   - capacityChanged: `true` if `capacity` was updated;
  ///     otherwise, `false`.
  mutating func ensureUniqueStorage(minimumCapacity requestedCapacity: Int, 
                                    allocate: (_ byteCount: Int) -> UnsafePointer<Void>) -> (reallocated: Bool, capacityChanged: Bool)
  ```

* **為 improt 依字母排序方便查找**

    ```swift
    import CoreLocation
    import MyThirdPartyModule
    import SpriteKit
    import UIKit
    ```
    
* **禁止水平對齊包含註解也不行**

    ```swift
    👎👎👎
    class Order {
        var name:        String
        var createdDate: Date
    }
    
    enum Nation {
        case australia           // 澳大利亞
        case unitedArabEmirates  // 阿拉伯聯合大公國
    }
    
    👍👍👍
    class Order {
        var name: String
        var createdDate: Date
    }
    
    enum Nation {
        /// 澳大利亞
        case australia        
           
        /// 阿拉伯聯合大公國
        case unitedArabEmirates  
    }

    ```
    
    
* **可不需要使用 self 就可以通過編譯的地方請省略 self**
* **善用 swift 型別推斷 （type inference）**


    ```swift
    👎👎👎
  let view = UIView(frame: CGRect.zero)  
  view.backgroundColor = UIColor.red
    let loginViewController: LoginViewController = LoginViewController()
    
    👍👍👍
  let view = UIView(frame: .zero)  
  view.backgroundColor = .red
    let loginViewController = LoginViewController()

    ```
    
* **enum 包含 associated values 使用時應為**
    
    > 範例中使用的三種寫法都是可以編譯，但請使用最後一種最為簡短清楚


    ```swift
    enum BinaryTree<Element> {
        indirect case subtree(left: BinaryTree<Element>, right: BinaryTree<Element>)
        case leaf(element: Element)
    }
    
    👎👎👎
    switch treeNode {
        case .subtree(let left, let right):
            // ...
        case .leaf(let element):
            // ...
    }
    
    switch treeNode {
        case .subtree(left: let left, right: let right):
            // ...
        case .leaf(element: let element):
            // ...
    }
    
    👍👍👍
    switch treeNode {
        case let .subtree(left, right):
            // ...
        case let .leaf(element):
            // ...
    }

    ```
